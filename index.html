<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>桌遊社花費分攤計算機</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link rel="stylesheet" href="style.css"> <!-- 引入獨立的 style.css -->
    <link rel="stylesheet" href="calculator.css">
    <link rel="stylesheet" href="modal_styles.css"> <!-- 引入新的模態框樣式 -->
</head>

<body>

    <div id="app" v-cloak>
        <h1>桌遊社花費分攤計算機</h1>
        <div class="top-controls">
            <div class="save-load-controls">
                <button @click="saveCurrentData" class="save-button">保存</button>
                <select v-model="selectedSaveEntry" @change="handleSaveEntrySelection" class="load-dropdown">
                    <option value="">選擇要載入的數據</option>
                    <option v-for="entry in savedEntries" :key="entry.date" :value="entry.date">
                        {{ entry.date }}
                    </option>
                </select>
                <button @click="clearInputs" class="clear-button">清空</button>
            </div>
        </div>
        <div v-if="loadMessage" class="message-display">
            {{ loadMessage }}
        </div>
        <div class="card">
            <h2>代墊費用</h2>
            <div class="input-group">
                <label>代墊餐費</label>
                <!-- 移除 input-row 容器，讓餐費區塊垂直堆疊 -->
                <div class="input-wrapper meal-entries">
                    <span>Zelda</span>
                    <div v-for="(meal, index) in reimbursable.me.meal" :key="index" class="meal-entry">
                        <input type="text"
                               :value="getMealAmountFieldValue('reimbursable.me.meal', index)"
                               @input="updateMealAmountFromInput({ path: 'reimbursable.me.meal', index: index, value: $event.target.value })"
                               @focus="openCalculatorForMeal('reimbursable.me.meal', index)"
                               placeholder="0" readonly>
                        <input type="text"
                               v-model="meal.note"
                               placeholder="備註">
                        <button @click="removeMealEntry('reimbursable.me.meal', index)" class="remove-meal-btn">－</button>
                    </div>
                    <button @click="addMealEntry('reimbursable.me.meal')" class="add-meal-btn">＋ 新增餐費</button>
                </div>
                <div class="input-wrapper meal-entries">
                    <span>Emma</span>
                    <div v-for="(meal, index) in reimbursable.wife.meal" :key="index" class="meal-entry">
                        <input type="text"
                               :value="getMealAmountFieldValue('reimbursable.wife.meal', index)"
                               @input="updateMealAmountFromInput({ path: 'reimbursable.wife.meal', index: index, value: $event.target.value })"
                               @focus="openCalculatorForMeal('reimbursable.wife.meal', index)"
                               placeholder="0" readonly>
                        <input type="text"
                               v-model="meal.note"
                               placeholder="備註">
                        <button @click="removeMealEntry('reimbursable.wife.meal', index)" class="remove-meal-btn">－</button>
                    </div>
                    <button @click="addMealEntry('reimbursable.wife.meal')" class="add-meal-btn">＋ 新增餐費</button>
                </div>
                <div class="input-wrapper meal-entries">
                    <span>Andrew</span>
                    <div v-for="(meal, index) in reimbursable.brother.meal" :key="index" class="meal-entry">
                        <input type="text"
                               :value="getMealAmountFieldValue('reimbursable.brother.meal', index)"
                               @input="updateMealAmountFromInput({ path: 'reimbursable.brother.meal', index: index, value: $event.target.value })"
                               @focus="openCalculatorForMeal('reimbursable.brother.meal', index)"
                               placeholder="0" readonly>
                        <input type="text"
                               v-model="meal.note"
                               placeholder="備註">
                        <button @click="removeMealEntry('reimbursable.brother.meal', index)" class="remove-meal-btn">－</button>
                    </div>
                    <button @click="addMealEntry('reimbursable.brother.meal')" class="add-meal-btn">＋ 新增餐費</button>
                </div>
            </div>
            <div class="input-group">
                <label>代墊車費</label>
                <div class="input-row">
                    <div class="input-wrapper">
                        <span>Zelda</span>
                        <input type="text" :value="getFieldValue('reimbursable.me.transport')" @input="updateValueFromInput({ path: 'reimbursable.me.transport', value: $event.target.value })" placeholder="0" @focus="openCalculator('reimbursable.me.transport')" readonly>
                    </div>
                    <div class="input-wrapper">
                        <span>Emma</span>
                        <input type="text" :value="getFieldValue('reimbursable.wife.transport')" @input="updateValueFromInput({ path: 'reimbursable.wife.transport', value: $event.target.value })" placeholder="0" @focus="openCalculator('reimbursable.wife.transport')" readonly>
                    </div>
                    <div class="input-wrapper">
                        <span>Andrew</span>
                        <input type="text" :value="getFieldValue('reimbursable.brother.transport')" @input="updateValueFromInput({ path: 'reimbursable.brother.transport', value: $event.target.value })" placeholder="0" @focus="openCalculator('reimbursable.brother.transport')" readonly>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>自家花費</h2>
            <div class="input-group">
                <label>自家餐費</label>
                <!-- 移除 input-row 容器，讓餐費區塊垂直堆疊 -->
                <div class="input-wrapper meal-entries">
                    <span>Zelda</span>
                    <div v-for="(meal, index) in our_own.me.meal" :key="index" class="meal-entry">
                        <input type="text"
                               :value="getMealAmountFieldValue('our_own.me.meal', index)"
                               @input="updateMealAmountFromInput({ path: 'our_own.me.meal', index: index, value: $event.target.value })"
                               @focus="openCalculatorForMeal('our_own.me.meal', index)"
                               placeholder="0" readonly>
                        <input type="text"
                               v-model="meal.note"
                               placeholder="備註">
                        <button @click="removeMealEntry('our_own.me.meal', index)" class="remove-meal-btn">－</button>
                    </div>
                    <button @click="addMealEntry('our_own.me.meal')" class="add-meal-btn">＋ 新增餐費</button>
                </div>
                <div class="input-wrapper meal-entries">
                    <span>Emma</span>
                    <div v-for="(meal, index) in our_own.wife.meal" :key="index" class="meal-entry">
                        <input type="text"
                               :value="getMealAmountFieldValue('our_own.wife.meal', index)"
                               @input="updateMealAmountFromInput({ path: 'our_own.wife.meal', index: index, value: $event.target.value })"
                               @focus="openCalculatorForMeal('our_own.wife.meal', index)"
                               placeholder="0" readonly>
                        <input type="text"
                               v-model="meal.note"
                               placeholder="備註">
                        <button @click="removeMealEntry('our_own.wife.meal', index)" class="remove-meal-btn">－</button>
                    </div>
                    <button @click="addMealEntry('our_own.wife.meal')" class="add-meal-btn">＋ 新增餐費</button>
                </div>
            </div>
            <div class="input-group">
                <label>自家車費</label>
                <div class="input-row">
                    <div class="input-wrapper">
                        <span>Zelda</span>
                        <input type="text" :value="getFieldValue('our_own.me.transport')" @input="updateValueFromInput({ path: 'our_own.me.transport', value: $event.target.value })" placeholder="0" @focus="openCalculator('our_own.me.transport')" readonly>
                    </div>
                    <div class="input-wrapper">
                        <span>Emma</span>
                        <input type="text" :value="getFieldValue('our_own.wife.transport')" @input="updateValueFromInput({ path: 'our_own.wife.transport', value: $event.target.value })" placeholder="0" @focus="openCalculator('our_own.wife.transport')" readonly>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>其他花費</h2>
            <div class="input-group">
                <label>Andrew 3D列印</label>
                <input type="text" :value="getFieldValue('reimbursable.brother.printer_3d')" @input="updateValueFromInput({ path: 'reimbursable.brother.printer_3d', value: $event.target.value })" placeholder="0" @focus="openCalculator('reimbursable.brother.printer_3d')" readonly>
            </div>
        </div>

        <div class="card results-card">
            <h2>計算結果</h2>
            <div class="result-item">
                <span class="label">{{ familyShouldReceiveText }}</span>
                <span class="value" :class="{'positive': familyShouldReceive > 0, 'negative': familyShouldReceive < 0, 'neutral': familyShouldReceive === 0}">{{ formatCurrency(Math.abs(familyShouldReceive)) }}</span>
            </div>
            <div class="result-item">
                <span class="label">{{ amountToGiveWifeText }}</span>
                <span class="value" :class="{'negative': amountToGiveWife > 0, 'positive': amountToGiveWife < 0, 'neutral': amountToGiveWife === 0}">
                    {{ formatCurrency(Math.abs(amountToGiveWife)) }}
                </span>
            </div>
        </div>

        <div class="card detail-card" v-if="allMealDetails.length > 0">
            <h2>餐費明細</h2>
            <ul>
                <li v-for="(detail, index) in allMealDetails" :key="index">
                    {{ detail.category }} - {{ detail.member }}: {{ formatCurrency(detail.amount) }}{{ detail.note ? ' (' + detail.note + ')' : '' }}
                </li>
            </ul>
        </div>

        <p class="footer-note">註：金額為綠色代表你應收的錢，紅色代表你應付的錢。</p>

        <!-- 計算機模組 -->
        <calculator-modal 
            :visible="calculatorState.visible"
            :initial-value="calculatorState.initialValue"
            :target-path="calculatorState.targetPath"
            :use-thousand-separator="true"
            @update:visible="calculatorState.visible = $event"
            @update:value="updateValueFromCalculator"
        ></calculator-modal>

        <!-- 自定義模態框 -->
        <div v-if="customModal.visible" class="custom-modal-overlay" @click.self="cancelCustomModal">
            <div class="custom-modal-content">
                <h3>{{ customModal.title }}</h3>
                <p>{{ customModal.message }}</p>
                <div v-if="customModal.type === 'confirm'" class="custom-modal-actions">
                    <button @click="confirmAction('load')" class="load-btn">載入</button>
                    <button @click="confirmAction('delete')" class="cancel-btn">刪除</button>
                    <button @click="confirmAction('changeDate')" class="change-date-btn">修改日期</button>
                </div>
            </div>
        </div>

        <!-- 短暫提示訊息模態框 -->
        <div v-if="tempMessageModal.visible" class="custom-modal-overlay temp-message-modal">
            <div class="custom-modal-content">
                <p>{{ tempMessageModal.message }}</p>
            </div>
        </div>

        <!-- 變更日期模態框 -->
        <div v-if="dateChangeModal.visible" class="custom-modal-overlay">
            <div class="date-change-modal-content">
                <h3>修改數據日期</h3>
                <p>將 <span style="font-weight: bold;">{{ dateChangeModal.originalDate }}</span> 的數據修改為：</p>
                <input type="date" v-model="dateChangeModal.newDate" ref="dateInput" @click="openDatePicker">
                <div class="modal-actions">
                    <button @click="confirmDateChange">確認修改</button>
                    <button @click="cancelDateChange" class="cancel-btn">取消</button>
                </div>
            </div>
        </div>

        <!-- 覆蓋確認模態框 -->
        <div v-if="overwriteConfirmModal.visible" class="custom-modal-overlay">
            <div class="custom-modal-content">
                <h3>覆蓋確認</h3>
                <p>{{ overwriteConfirmModal.message }}</p>
                <div class="custom-modal-actions">
                    <button @click="handleOverwriteChoice(true)" class="overwrite-btn">覆蓋</button>
                    <button @click="handleOverwriteChoice(false)" class="cancel-btn">取消</button>
                </div>
            </div>
        </div>

    </div>

    <script type="module">
        // 引入 CalculatorModal 組件
        import CalculatorModal from './CalculatorModal.js';
        // 定義初始數據結構
        const initialData = {
            reimbursable: {
                me: {
                    meal: [{ amount: 0, note: '' }], // 將餐費改為陣列，用於儲存多個餐費項目
                    transport: 0
                },
                wife: {
                    meal: [{ amount: 0, note: '' }], // 將餐費改為陣列
                    transport: 0
                },
                brother: {
                    meal: [{ amount: 0, note: '' }], // 將餐費改為陣列
                    transport: 0,
                    printer_3d: 0
                }
            },
            our_own: {
                me: {
                    meal: [{ amount: 0, note: '' }], // 將餐費改為陣列
                    transport: 0
                },
                wife: {
                    meal: [{ amount: 0, note: '' }], // 將餐費改為陣列
                    transport: 0
                }
            },
            calculatorState: {
                visible: false,
                initialValue: '',
                targetPath: ''
            }
        };

        // Vue.js 應用邏輯
        const {
            createApp
        } = Vue;

        const app = createApp({
            data() {
                return {
                    ...JSON.parse(JSON.stringify(initialData)), // 深度複製初始數據
                    savedEntries: [], // 新增用於儲存載入的數據
                    selectedSaveEntry: '', // 新增用於選擇載入的數據
                    loadMessage: '', // 新增用於顯示載入/保存提示訊息
                    customModal: { // 新增自定義模態框狀態
                        visible: false,
                        title: '',
                        message: '',
                        type: 'confirm' // 'confirm' 或 'info'
                    },
                    tempMessageModal: { // 新增短暫提示訊息模態框狀態
                        visible: false,
                        message: ''
                    },
                    pendingSaveEntry: '', // 新增用於暫存載入/刪除選擇的日期
                    dateChangeModal: { // 新增變更日期模態框狀態
                        visible: false,
                        originalDate: '',
                        newDate: ''
                    },
                    overwriteConfirmModal: { // 新增覆蓋確認模態框狀態
                        visible: false,
                        originalDate: '',
                        newDate: '',
                        message: ''
                    }
                };
            },
            mounted() {
                const savedData = localStorage.getItem('familyCostCalculator');
                if (savedData) {
                    const parsedData = JSON.parse(savedData);
                    // 使用新的 assignSavedData 方法來處理載入的數據
                    this.assignSavedData(this.reimbursable, parsedData.reimbursable);
                    this.assignSavedData(this.our_own, parsedData.our_own);
                } else {
                    // this.loadSavedEntries(); // 移除這行
                }
                this.loadSavedEntries(); // 在 mounted 時載入已保存的數據，確保總是執行
            },
            watch: {
                // 監聽 reimbursable 變化，自動保存當前數據
                'reimbursable': {
                    handler(newValue) {
                        localStorage.setItem('familyCostCalculator', JSON.stringify({
                            reimbursable: newValue,
                            our_own: this.our_own,
                        }));
                    },
                    deep: true,
                    immediate: false
                },
                // 監聽 our_own 變化，自動保存當前數據
                'our_own': {
                    handler(newValue) {
                        localStorage.setItem('familyCostCalculator', JSON.stringify({
                            reimbursable: this.reimbursable,
                            our_own: newValue,
                        }));
                    },
                    deep: true,
                    immediate: false
                }
            },
            computed: {
                // 我們家應獲得差額
                familyShouldReceive() {
                    const myTotal = this.calculateMemberTotal(this.reimbursable.me);
                    const wifeTotal = this.calculateMemberTotal(this.reimbursable.wife);
                    const brotherTotal = this.calculateMemberTotal(this.reimbursable.brother);
                    const result = myTotal + wifeTotal - brotherTotal;
                    return Math.round(result);
                },
                // 我應再給Emma
                amountToGiveWife() {
                    // 1. 計算我的總支出
                    const myTotalOwnExpense = this.calculateMemberTotal(this.reimbursable.me) + this.calculateMemberTotal(this.our_own.me);
                    // 2. 計算Emma的總支出
                    const wifeTotalOwnExpense = this.calculateMemberTotal(this.reimbursable.wife) + this.calculateMemberTotal(this.our_own.wife);
                    // 3. 計算夫妻兩人總支出
                    const totalFamilyExpense = myTotalOwnExpense + wifeTotalOwnExpense - this.familyShouldReceive;
                    // 4. 計算平均每人應支出
                    const averageExpense = totalFamilyExpense / 2;
                    // 5. 計算我應給Emma的金額 (平均值 - 我的實際支出)
                    const printer3dValue = Number(this.reimbursable.brother.printer_3d.toString().replace(/,/g, '') || 0);
                    const result = averageExpense - (myTotalOwnExpense - this.familyShouldReceive) + (Math.floor(printer3dValue / 2));
                    return Math.round(result);
                },
                // 動態變更標題文字
                amountToGiveWifeText() {
                    if (this.amountToGiveWife >= 0) {
                        return "Zelda應再給Emma";
                    } else {
                        return "Emma應再給Zelda";
                    }
                },
                // 動態變更我們家應獲得差額的標題文字
                familyShouldReceiveText() {
                    if (this.familyShouldReceive >= 0) {
                        return "我們家應獲得差額";
                    } else {
                        return "我們家應付出差額";
                    }
                },
                // 餐費明細
                allMealDetails() {
                    const details = [];

                    // 定義類別名稱的映射
                    const categoriesMap = {
                        reimbursable: '代墊餐費',
                        our_own: '自家餐費'
                    };

                    // 定義成員名稱的映射
                    const membersMap = {
                        me: 'Zelda',
                        wife: 'Emma',
                        brother: 'Andrew'
                    };

                    // 遍歷主要類別 (reimbursable, our_own)
                    for (const categoryKey in categoriesMap) {
                        if (Object.hasOwnProperty.call(this, categoryKey)) {
                            const categoryName = categoriesMap[categoryKey];
                            const categoryData = this[categoryKey]; // 取得該類別下的所有成員資料

                            // 遍歷該類別下的每個成員 (me, wife, brother)
                            for (const memberKey in categoryData) {
                                if (Object.hasOwnProperty.call(categoryData, memberKey) && categoryData[memberKey].meal) {
                                    const memberName = membersMap[memberKey];
                                    // 遍歷該成員的餐費陣列
                                    categoryData[memberKey].meal.forEach(meal => {
                                        if (Number(meal.amount.toString().replace(/,/g, '')) > 0) { // 只顯示金額大於0的項目
                                            details.push({
                                                category: categoryName,
                                                member: memberName,
                                                amount: meal.amount,
                                                note: meal.note
                                            });
                                        }
                                    });
                                }
                            }
                        }
                    }
                    return details;
                }
            },
            methods: {
                // 新增：處理從 localStorage 載入數據時的結構轉換
                assignSavedData(targetObj, sourceObj) {
                    if (!sourceObj) return;

                    for (const key in targetObj) {
                        if (Object.hasOwnProperty.call(targetObj, key)) {
                            if (key === 'meal') {
                                if (Array.isArray(sourceObj[key])) {
                                    // 如果 source meal 已經是陣列，使用它，確保 amount/note 結構
                                    targetObj[key] = sourceObj[key].map(item => ({
                                        amount: Number(item.amount.toString().replace(/,/g, '') || 0),
                                        note: item.note || ''
                                    }));
                                    if (targetObj[key].length === 0) { // 確保如果為空，至少有一個空項目
                                        targetObj[key].push({ amount: 0, note: '' });
                                    }
                                } else if (typeof sourceObj[key] === 'number' || typeof sourceObj[key] === 'string') {
                                    // 如果舊的 meal 數據是數字/字串，轉換為新的陣列結構
                                    targetObj[key] = [{ amount: Number(sourceObj[key].toString().replace(/,/g, '')) || 0, note: '' }];
                                } else {
                                    // 如果 source 數據缺失或 meal 無效，預設為空項目
                                    targetObj[key] = [{ amount: 0, note: '' }];
                                }
                            } else if (typeof targetObj[key] === 'object' && targetObj[key] !== null) {
                                // 遞迴處理巢狀物件 (例如 me, wife, brother)
                                this.assignSavedData(targetObj[key], sourceObj[key] || {});
                            } else if (sourceObj[key] !== undefined) {
                                // 對於其他簡單屬性 (例如 transport, printer_3d)，直接賦值 (確保為數字)
                                targetObj[key] = Number(sourceObj[key].toString().replace(/,/g, '')) || 0;
                            }
                        }
                    }
                },
                // 清空所有輸入
                clearInputs() {
                    // 使用初始數據結構重置所有欄位
                    Object.assign(this.$data, JSON.parse(JSON.stringify(initialData)));
                    localStorage.removeItem('familyCostCalculator');
                    this.selectedSaveEntry = '';
                    // 重新載入保存的項目，確保下拉選單更新但數據不被清除
                    this.loadSavedEntries(); 
                    this.selectedSaveEntry = ''; // 再次確保 selectedSaveEntry 為空，覆蓋 loadSavedEntries 的預設選擇
                },
                // 格式化貨幣顯示 (固定顯示千位分隔符號)
                formatCurrency(value) {
                    if (typeof value === 'number' && isFinite(value)) {
                        return value.toLocaleString('zh-TW', { maximumFractionDigits: 10 });
                    }
                    // 如果是字串，嘗試轉換為數字再格式化
                    const numValue = Number(value.toString().replace(/,/g, ''));
                    if (!isNaN(numValue) && isFinite(numValue)) {
                        return numValue.toLocaleString('zh-TW', { maximumFractionDigits: 10 });
                    }
                    return value; // 無法格式化則返回原始值
                },
                getFieldValue(fieldPath) {
                    const { target, key } = this.getTargetObjectAndKey(fieldPath);
                    // 在回傳前使用 formatCurrency 格式化
                    return this.formatCurrency((target && typeof target === 'object' && key in target) ? target[key] : '0');
                },
                // 輔助函式：根據路徑獲取目標物件和最終屬性鍵
                getTargetObjectAndKey(path) {
                    const parts = path.split('.');
                    let target = this;
                    for (let i = 0; i < parts.length - 1; i++) {
                        target = target[parts[i]];
                    }
                    return { target, key: parts[parts.length - 1] };
                },
                openCalculator(fieldPath) {
                    this.calculatorState.targetPath = fieldPath;
                    // 獲取當前欄位的值作為初始值，並在傳遞給計算機之前移除千位分隔符號
                    const { target, key } = this.getTargetObjectAndKey(fieldPath);
                    const currentValue = target[key]; // 現在 currentValue 是字串
                    this.calculatorState.initialValue = (currentValue !== undefined && currentValue !== null) ? currentValue.toString().replace(/,/g, '') : '';
                    this.calculatorState.visible = true;
                },
                updateValueFromCalculator({ path, value }) {
                    const pathParts = path.split('.');
                    // 檢查 path 是否包含數字索引，判斷是否為餐費項目
                    const isMealEntry = !isNaN(parseInt(pathParts[pathParts.length - 2]));

                    if (isMealEntry) {
                        const lastPart = pathParts.pop(); // 應該是 'amount'
                        const index = parseInt(pathParts.pop()); // 應該是餐費的索引
                        const actualPath = pathParts.join('.'); // 應該是 'reimbursable.me.meal' 等

                        const { target, key } = this.getTargetObjectAndKey(actualPath);

                        if (target && Array.isArray(target[key]) && target[key][index]) {
                            target[key][index][lastPart] = value; // 更新 amount
                        }
                    } else {
                        // 如果不是餐費項目，則走原有邏輯 (例如車費或3D列印費)
                        const { target, key } = this.getTargetObjectAndKey(path);
                        target[key] = value; // 直接賦值為字串 (已由 CalculatorModal 格式化)
                    }
                },
                updateValueFromInput({ path, value }) {
                    const { target, key } = this.getTargetObjectAndKey(path);
                    // 直接儲存輸入字串，計算時再轉換
                    target[key] = value;
                },
                // 計算單個成員的總支出
                calculateMemberTotal(memberExpenses) {
                    let total = 0;
                    for (const key in memberExpenses) {
                        if (Object.hasOwnProperty.call(memberExpenses, key)) {
                            if (key === 'meal' && Array.isArray(memberExpenses[key])) {
                                memberExpenses[key].forEach(meal => {
                                    total += Number(meal.amount.toString().replace(/,/g, '') || 0);
                                });
                            } else {
                                // 將儲存的字串轉換為數字進行計算
                                total += Number(memberExpenses[key].toString().replace(/,/g, '') || 0);
                            }
                        }
                    }
                    return total;
                },
                // 新增餐費項目
                addMealEntry(memberPath) {
                    const { target, key } = this.getTargetObjectAndKey(memberPath);
                    target[key].push({ amount: 0, note: '' });
                },
                // 移除餐費項目
                removeMealEntry(memberPath, index) {
                    const { target, key } = this.getTargetObjectAndKey(memberPath);
                    target[key].splice(index, 1);
                },
                // 獲取餐費項目的金額值
                getMealAmountFieldValue(memberPath, index) {
                    const { target, key } = this.getTargetObjectAndKey(memberPath);
                    // 在回傳前使用 formatCurrency 格式化
                    return this.formatCurrency(target[key][index].amount);
                },
                // 更新餐費項目的金額值
                updateMealAmountFromInput({ path, index, value }) {
                    const { target, key } = this.getTargetObjectAndKey(path);
                    target[key][index].amount = value;
                },
                // 為餐費項目開啟計算機
                openCalculatorForMeal(memberPath, index) {
                    const { target, key } = this.getTargetObjectAndKey(memberPath);
                    const meal = target[key][index];
                    this.calculatorState.targetPath = `${memberPath}.${index}.amount`;
                    this.calculatorState.initialValue = meal.amount.toString().replace(/,/g, '');
                    this.calculatorState.visible = true;
                },
                // 新增：保存當前數據
                saveCurrentData() {
                    const today = new Date().toISOString().slice(0, 10); // 使用 ISO 格式的日期，例如 "2025-09-12"
                    let currentData = {
                        reimbursable: JSON.parse(JSON.stringify(this.reimbursable)),
                        our_own: JSON.parse(JSON.stringify(this.our_own)),
                        date: today
                    };

                    // 檢查是否已存在當天數據，如果存在則更新，否則新增
                    const existingIndex = this.savedEntries.findIndex(entry => entry.date === today);
                    if (existingIndex !== -1) {
                        this.savedEntries[existingIndex] = currentData;
                        this.showTempMessage(`數據已更新至 ${today}。`);
                    } else {
                        // 如果超過20筆，移除最舊的一筆
                        if (this.savedEntries.length >= 20) {
                            this.savedEntries.shift(); // 移除第一個元素（最舊的）
                        }
                        this.savedEntries.push(currentData);
                        this.showTempMessage(`保存成功：${today}。`);
                    }
                    localStorage.setItem('familyCostCalculatorSavedEntries', JSON.stringify(this.savedEntries));
                    this.selectedSaveEntry = ''; // 保存後重置下拉選單為空
                },
                // 新增：處理載入/刪除選擇 (顯示自定義模態框)
                handleSaveEntrySelection() {
                    if (!this.selectedSaveEntry) {
                        return; // 如果沒有選擇任何項目，直接返回
                    }
                    this.customModal.title = '操作確認';
                    this.customModal.message = `您想對 ${this.selectedSaveEntry} 的數據執行什麼操作？`;
                    this.customModal.type = 'confirm';
                    this.customModal.visible = true;
                    // 將選擇的日期暫存起來，待模態框確認後使用
                    this.pendingSaveEntry = this.selectedSaveEntry;
                },
                // 處理模態框確認後的載入/刪除邏輯
                processSaveEntrySelection(action) {
                    const entryDate = this.pendingSaveEntry;
                    if (!entryDate) return; // 沒有待處理的選擇

                    if (action === 'load') {
                        this.loadDataByDate(entryDate);
                    } else if (action === 'delete') {
                        this.deleteDataByDate(entryDate);
                    } else if (action === 'changeDate') {
                        // 修改日期邏輯
                        this.customModal.title = '修改日期';
                        this.customModal.message = `您想將 ${entryDate} 的數據修改為哪一天？`;
                        this.customModal.type = 'info'; // 修改日期是資訊提示，不是確認
                        this.customModal.visible = true;
                        this.pendingSaveEntry = entryDate; // 暫存選擇的日期
                    }
                    this.pendingSaveEntry = ''; // 清空待處理的選擇
                    this.selectedSaveEntry = ''; // 重置下拉選單
                },
                // 新增：更新數據的日期
                updateEntryDate(originalDate, newDate, overwrite = false) {
                    const originalEntryIndex = this.savedEntries.findIndex(entry => entry.date === originalDate);
                    const newDateEntryIndex = this.savedEntries.findIndex(entry => entry.date === newDate);

                    if (originalEntryIndex === -1) {
                        this.showTempMessage('未找到原始數據可更新日期。');
                        return;
                    }

                    // 如果新日期與原始日期相同，則不執行任何操作
                    if (originalDate === newDate) {
                        this.showTempMessage('日期未更改。');
                        return;
                    }

                    // 檢查新日期是否已經存在 (只在非覆蓋模式下檢查)
                    // 如果新日期存在且不是修改自己的日期，則觸發覆蓋確認
                    if (!overwrite && newDateEntryIndex !== -1 && originalEntryIndex !== newDateEntryIndex) {
                        this.showOverwriteConfirm(originalDate, newDate);
                        return;
                    }

                    // --- 實際的更新/覆蓋邏輯從這裡開始 --- 

                    if (overwrite && newDateEntryIndex !== -1 && originalEntryIndex !== newDateEntryIndex) {
                        // 使用者選擇覆蓋。
                        // 這意味著：將 originalDate 項目移動到 newDate，並刪除原 newDate 項目。

                        // 1. 儲存 originalDate 的數據副本，準備移動
                        const dataToMove = { ...this.savedEntries[originalEntryIndex] };
                        dataToMove.date = newDate; // 將副本的日期更新為新日期

                        // 2. 刪除原 newDate 的數據項目
                        this.savedEntries.splice(newDateEntryIndex, 1);

                        // 3. 調整 originalEntryIndex，因為刪除了一個項目
                        // 如果 originalEntryIndex 在 newDateEntryIndex 之後，則索引會減 1
                        let actualOriginalEntryIndex = originalEntryIndex;
                        if (originalEntryIndex > newDateEntryIndex) {
                            actualOriginalEntryIndex--;
                        }

                        // 4. 刪除原 originalDate 的數據項目
                        this.savedEntries.splice(actualOriginalEntryIndex, 1);

                        // 5. 將移動後的數據（dataToMove）添加到 savedEntries
                        this.savedEntries.push(dataToMove);

                        this.showTempMessage(`數據已從 ${originalDate} 移至 ${newDate}，原 ${newDate} 數據已被覆蓋。`);

                    } else { // 正常修改日期 (沒有衝突，或選擇不覆蓋)
                        // 這處理了以下情況：
                        // 1. 使用者將日期更改為一個獨特的新日期。
                        // 2. 使用者選擇取消覆蓋 (overwrite 為 false，因此執行此路徑)。
                        
                        // 更新原始項目的日期
                        this.savedEntries[originalEntryIndex].date = newDate;
                        this.showTempMessage(`數據日期已從 ${originalDate} 更新為 ${newDate}。`);
                    }

                    // 重新排序 savedEntries 以保持有序
                    this.savedEntries.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
                    localStorage.setItem('familyCostCalculatorSavedEntries', JSON.stringify(this.savedEntries));
                },
                // 載入指定日期的數據
                loadDataByDate(date) {
                    const savedData = this.savedEntries.find(entry => entry.date === date);
                    if (savedData) {
                        Object.assign(this.reimbursable, JSON.parse(JSON.stringify(savedData.reimbursable)));
                        Object.assign(this.our_own, JSON.parse(JSON.stringify(savedData.our_own)));
                        this.showTempMessage(`已載入 ${date} 數據。`);
                    } else {
                        this.showTempMessage('未找到數據。');
                    }
                },
                // 新增：刪除指定日期的數據
                deleteDataByDate(date) {
                    const initialLength = this.savedEntries.length;
                    this.savedEntries = this.savedEntries.filter(entry => entry.date !== date);
                    if (this.savedEntries.length < initialLength) {
                        localStorage.setItem('familyCostCalculatorSavedEntries', JSON.stringify(this.savedEntries));
                        this.showTempMessage(`已刪除 ${date} 數據。`);
                    } else {
                        this.showTempMessage('未找到數據可刪除。');
                    }
                },
                // 新增：載入已保存的數據
                loadSavedEntries() {
                    const savedEntries = localStorage.getItem('familyCostCalculatorSavedEntries');
                    if (savedEntries) {
                        this.savedEntries = JSON.parse(savedEntries);
                    }
                    this.selectedSaveEntry = ''; // 確保初始載入時為空
                },
                // 新增：顯示短暫的提示訊息
                showTempMessage(message) {
                    this.tempMessageModal.message = message;
                    this.tempMessageModal.visible = true;
                    if (this.messageTimeout) {
                        clearTimeout(this.messageTimeout);
                    }
                    // 根據訊息長度自動調整顯示時間
                    const messageLength = message.length; // 訊息字數
                    const readingSpeed = 18; // 每秒閱讀字數 (例如 4 個中文字/秒)
                    let displayDuration = Math.ceil(messageLength / readingSpeed) * 1000; // 計算毫秒數

                    // 設定最小和最大顯示時間
                    const minDuration = 1500; // 1.5 秒
                    const maxDuration = 5000; // 5 秒

                    displayDuration = Math.max(minDuration, Math.min(displayDuration, maxDuration));

                    this.messageTimeout = setTimeout(() => {
                        this.tempMessageModal.visible = false;
                    }, displayDuration); // 根據計算出的時間消失
                },
                // 自定義模態框確認動作
                confirmAction(actionType) {
                    this.customModal.visible = false;
                    if (actionType === 'load') {
                        this.processSaveEntrySelection('load'); // 點擊「載入」表示載入
                    } else if (actionType === 'delete') {
                        this.processSaveEntrySelection('delete'); // 點擊「刪除」表示刪除
                    } else if (actionType === 'changeDate') {
                        // 開啟修改日期模態框
                        this.dateChangeModal.originalDate = this.pendingSaveEntry; // 將當前選擇的日期作為原始日期
                        this.dateChangeModal.newDate = this.pendingSaveEntry; // 預設新日期為原始日期
                        this.dateChangeModal.visible = true;
                    }
                },
                // 確認修改日期
                confirmDateChange() {
                    this.updateEntryDate(this.dateChangeModal.originalDate, this.dateChangeModal.newDate);
                    this.dateChangeModal.visible = false;
                    this.selectedSaveEntry = ''; // 修改日期後重置下拉選單
                },
                // 取消修改日期
                cancelDateChange() {
                    this.dateChangeModal.visible = false;
                    this.selectedSaveEntry = ''; // 取消修改日期後重置下拉選單
                },
                // 取消自定義模態框
                cancelCustomModal() {
                    this.customModal.visible = false;
                    this.selectedSaveEntry = ''; // 重置下拉選單
                    this.pendingSaveEntry = ''; // 清空暫存的日期
                },
                // 開啟日期選擇器 (用於 input type="date")
                openDatePicker() {
                    // 檢查瀏覽器是否支援 showPicker() 方法
                    if (this.$refs.dateInput && typeof this.$refs.dateInput.showPicker === 'function') {
                        this.$refs.dateInput.showPicker();
                    }
                },
                // 顯示覆蓋確認模態框
                showOverwriteConfirm(originalDate, newDate) {
                    this.overwriteConfirmModal.originalDate = originalDate;
                    this.overwriteConfirmModal.newDate = newDate;
                    this.overwriteConfirmModal.message = `日期 ${newDate} 已存在。您要覆蓋現有數據嗎？`;
                    this.overwriteConfirmModal.visible = true;
                },
                // 處理覆蓋確認模態框的選擇
                handleOverwriteChoice(overwrite) {
                    this.overwriteConfirmModal.visible = false;
                    if (overwrite) {
                        // 執行覆蓋操作
                        this.updateEntryDate(this.overwriteConfirmModal.originalDate, this.overwriteConfirmModal.newDate, true);
                    } else {
                        // 取消覆蓋，重置日期變更模態框狀態
                        this.dateChangeModal.visible = false;
                        this.selectedSaveEntry = '';
                    }
                }
            },
            components: {
                CalculatorModal
            }
        }).mount('#app');
    </script>

</body>

</html>